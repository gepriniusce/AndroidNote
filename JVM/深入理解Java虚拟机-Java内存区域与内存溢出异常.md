


# 概述
Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄露和溢出方面的问题，
如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。
接下来就从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题。

也是了解Java虚拟器的内存管理。

# 运行时数据区域
![](https://user-gold-cdn.xitu.io/2018/1/25/1612ce5ab5163a54?w=568&h=445&f=png&s=46570)    
## 程序计数器（Program Counter Register）

我的理解就是ID。给当前线程一个ID，通过改变这个ID来选取下一条需要执行的字节码指令。

“线程私有”：每条线程都需要一个独立的程序计数器。

一个处理器（一个内核）在一个确定的时刻只会执行一条线程中的指令。

## Java虚拟机栈（Java Virtual Machine Stacks）
生命周期与线程共存

用于存储局部变量表、操作栈、动态链接、方法出口等信息。

### 帧栈（Stack Frame）
每个方法被执行的时候都会创建一个帧栈。

方法被调用直至执行完成的过程=从入栈到出栈过程。

### 局部变量表
存放编译期可知的各种基本数据类型`（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等于对象本身，根据不同虚拟机实现，它可能是一个指向对象起始地址的指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）` 和 returnAddress类型`（指向了一条字节码指令的地址）`。

所需的内存空间在编译期间完成分配。

### 异常
* StackOverflowError：当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。
* OutOfMemoryError：当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出 OutOfMemoryError。

## 本地方法栈（Native Method Stacs）
本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行 Java 代码方法服务，而本地方法栈是为 Native 方法服务。
### 异常
* StackOverflowError
* OutOfMemoryError

## Java堆（Java Heap）
内存最大。

是被所有线程共享的一块内存区域。

在虚拟机启动时创建。

用于存放对象实例。

是垃圾收集器管理的主要区域("GC堆")。

### 异常
当堆无法再扩展时，会抛出 OutOfMemoryError 异常。

## 方法区（Method Area）
是被所有线程共享的一块内存区域。（与Java堆一样）

方法区存放的是类信息、常量、静态变量、即时编译期编译后的代码等数据。
### 回收
由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。垃圾收集的行为在这个区域是比较少出现的。

另外，对这块区域主要是针对常量池回收，值得注意的是 JDK1.7 已经把常量池转移到堆里面了

## 运行时常量池（Runtime Constant Pool）
是方法区的一部分。
存放Class文件中常量池。
用于存放编译期生成的各种字面量和符号引用，在类加载后存放到方法区的运行时常量中。
### 异常
受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## 直接内存（Direct Memory）
虚拟机运行时数据区和Java虚拟机规范中定义的内存区域**以外**的内存。

这部分内存也被频繁地使用。

在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以适用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java和Native堆中来回复制数据。

### 异常
当各个内存区域的总和大于物理内存限制（包括物理上的和操作系统的限制），从而导致动态扩展时出现OutOfMemoryError异常。

# 对象访问
`Object obj=new Object();`
#### Object obj-
将会放映到Java栈的本地变量表中，作为一个reference类型数据出现。
#### new Object()-
将会反映到Java堆中，形成一块储存了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。
#### Java堆中
还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息。
#### 方法区中
则存储这些类型数据。（对象类型、父类、实现的接口、方法等）
#### reference类型
在Java虚拟机范围里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同


## 主流访问方式有两种
- 使用句柄访问方式--
Java堆中划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。

![](https://user-gold-cdn.xitu.io/2018/3/15/16225d286ea8174a?w=679&h=346&f=png&s=33663)
优点：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改句柄中的实例数据指针，而reference本身不需要被修改。

- 使用直接指针访问方式--
Java堆对象的布局中就必须考虑如何防止访问类型数据相关信息，reference中直接存储的就是对象地址。

![](https://user-gold-cdn.xitu.io/2018/3/15/16225d52323e2d97?w=690&h=356&f=png&s=32438)
优点：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。。

# OutOfMemoryError异常
## Java堆溢出
对象数量到达最大堆的容量限制后产生内存溢出异常。
java.lang.OutOfMemoryError
Java heap space

一般需要借助内存映像分析工具来解决。
内存泄露（Memory Leak）该回收的没被回收
内存溢出（Memory Overflow）空间不够
## 虚拟机栈和本地方法栈溢出
StackOverflowError：线程请求的栈深度大于虚拟机所允许的最大深度。
OutOfMemoryError：虚拟机在扩展栈时无法申请到足够的内存空间
## 运行时常量池溢出
常量池分配在方法区内。
OutOfMemoryError
PermGen Space
## 方法区溢出
用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收掉，判断条件非常苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。
## 本机直接内存溢出
并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。


