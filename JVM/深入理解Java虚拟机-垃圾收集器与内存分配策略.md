# 概述

垃圾收集（Garbage Collection，GC）

GC需要完成的三件事：

* 哪些内存需要回收？

* 什么时候回收？

* 如何回收？



内存运行时区域其中的`程序计数器、虚拟机栈、本地方法栈`三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着系统回收了。



而`Java堆和方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。

---

# 对象已死？

Java堆中几乎存放着Java世界中的所有对象实例，GC在对堆进行回收钱，第一件事情就是确定这些对象有哪些还“存活着”，哪些已经“死去”（就是不可能再被任何途径适用的对象）。

如何判断对象已死？

## 引用计数算法
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器减1；其中计数器为0的对象是不可能再被使用的已死对象。

引用计数算法的实现很简单，但有个巨大的缺点，当两个对象相互引用时，这两个对象就不会被回收，导致内存泄漏。
## 根搜索算法（GC Roots Tracing）
通过一系列的称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所经过
的路径称为引用链（Reference Chain）;
当一个对象到GC Roots没有任何引用链相连（在图论中称为对象不可达）时，这个对象就是不可用的。

![仍然存活的对象](https://user-gold-cdn.xitu.io/2018/4/10/162ab54a5412b115?w=331&h=440&f=png&s=1484)


![判定可回收的对象](https://user-gold-cdn.xitu.io/2018/4/10/162ab54e352ded0b?w=346&h=248&f=png&s=1092)

在java语言中，可作为`GC Roots`的对象包括：
* 虚拟机栈（`栈帧中的本地变量表`）中引用的对象
* 方法区中`类静态属性`引用的对象
* 方法区中`常量`引用的对象
* 本地方法栈中`JNI`(即一般说的Native方法)引用的对象

## 再谈引用
java的引用可以分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)

* 强引用：是指在程序代码中直接存在的引用，譬如"Object obj=new Object();"。`只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。`

* 软引用：还有用但是并非必需的引用，`在系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收`，若还是没有足够的内存，才会抛出内存溢出异常。

* 弱引用：非必需的对象，`只能生存到下一次垃圾收集发生之前`。当垃圾收集器工作时，无论内存是否够用都将回收这些对象。

* 虚引用：`一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例。`为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。

## 生存还是死亡（宣告一个对象死亡的过程）
要真正宣告一个对象死亡，至少要经历两次标记过程：

* 若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被`第一次标记` 并且`进行一次筛选`。筛选的条件是此对象是否有必要执行finalize()方法（如当对象没有重写finalize()方法或者finalize()方法已经被虚拟机调用过则认为没有必要执行）。

* 如果有必要执行则将该对象放置在F-Queue队列中，并在稍后由一个由虚拟机自己建立的、低优先级的Finalizer线程去执行它；稍后GC将对F-Queue中的对象进行第二次标记，如果对象还是没有被引用，则会被回收。

但是不建议通过finalize()方法“拯救”对象，因为它运行代价高、不确定性大、无法保证各个对象的调用顺序。
## 回收方法区
很多人认为方法区（HotSopt中的永久代）是没有垃圾收集的，java虚拟机规范中也没有要求需要对方法区实现垃圾收集。

> 永久代（方法区）的垃圾收集主要回收两部分内容：废弃常量和无用的类

*` 废弃常量`：假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫 做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。

* `无用的类`：同时满足下面3个条件的类（实例、类加载器被回收，java.lang.Class对象没有被引用）。

1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

2.加载该类的ClassLoader已经被回收。

3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

---

# 垃圾收集算法
### 标记-清除算法（最基础）
算法分为两个阶段：标记和清除

标记：首先标记所有需要回收的对象

清除：在标记完成后统一回收所有被标记的对象

缺点

* 效率问题，标记和清除两个过程的效率都不高（回收后空间碎片过多，再次回收（即可达性分析时）有时需要遍历整个内存区域）。
* 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存,而不得不提前触发另一次垃圾收集动作。

### 复制算法（新生代算法）(Copying)

思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分。

优点

* 每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

缺点
* 代价是将内存缩小为了原来的一半，未免太高了一点。

解决方法

* 新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。
* 在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden和两块Survivor，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用。

### 标记-整理算法（老年代算法）(Mark-Compact)
标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法
* 当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为新生代和老生代，根据各个年代采用适当的收集算法。
* 新生代一般采用复制算法(Copying)。
* 老生代一般采用标记-清理(Mark-Sweep)或者标记-整理(Mark-Compact) 进行回收。

# 垃圾收集器
# 内存分配与回收策略